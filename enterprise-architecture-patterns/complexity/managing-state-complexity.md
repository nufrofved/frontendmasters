> 대규모 소프트웨어 시스템의 개발 및 유지 관리에서 가장 큰 문제는 "복잡성"임. 큰 시스템은 이해하기 어려움.

# 복잡성이란?

- "상태 관리"
- 상태 관리를 제대로 하지 않으면 애플리케이션 내에서 이동 또는 소통하는 능력(제어 흐름)에 문제가 발생함.
- 상태 관리를 실패하면 코드 양이 기하급수적으로 증가함.
- 프로그래밍의 철삼각은 상태 관리, 코드 양, 제어 흐름임.
- 프로그래머로서 모든 작업은 다음에 집중됨: 상태를 효과적으로 관리하는 방법, 제어 흐름(통신)을 관리하는 방법, 그리고 이를 최소한의 코드로 구현하는 방법.

# 복잡성과 연옥

- 연옥에 빠질지 여부는 복잡성을 얼마나 잘 관리하는지에 달려 있음.
- 'YOLO 커밋'을 한 적이 있다면, 서서히 연옥에 발을 들여놓고 있다는 것을 깨달았을 것임.
- 브라운필드 프로젝트에 갑자기 투입된 적이 있다면, "무슨 일이 일어나고 있는지 전혀 모르겠어, 난 지옥에 있어"라고 생각했을 것임.
- 나도 그런 경험이 있고, 아마 다른 사람들도 비슷한 경험을 했을 것임. 따라서 복잡성은 자신이 빠진 연옥의 수준과 직접적인 관련이 있음.

# 공유 가변 상태는 매우 위험하다 (Shared mutable state is incredibly dangerous)

- 나는 아마존에서 물건을 사는 것을 좋아하고, 아내도 아마존에서 물건을 사는 것을 좋아함.
- 내가 컴퓨터에서 책을 장바구니에 추가했을 때, 장바구니에 책 대신 다른 여섯 가지 항목이 들어 있음.
- 이유는 아내가 같은 계정을 사용하고 있기 때문에 장바구니가 공유 상태에 있어서 예측할 수 없는 결과가 나타남.
- 이제 장바구니에 있는 물건의 의도를 파악해야 하고, 이것이 무엇을 의미하는지 알아야 함.
- 코드를 작성할 때도 비슷한 상황이 발생하면, 예상하지 못한 무언가가 나타나고 그 이유를 파악해야 하는 상황에 직면하게 됨.
- 재미있는 이야기로, 장바구니에 장난감이 여러 개 들어 있었고, 아내가 넣은 줄 알고 모두 구매했는데 알고 보니 9살 아들이 장난으로 넣어둔 것임. 이로 인해 예측 불가능한 제어 흐름이 발생함.
- 상태 관리와 제어 흐름을 제대로 하지 않으면, 상태를 관리하기 위해 추가 코드를 작성해야 하고, 코드 재사용 능력이 크게 줄어들며, 이는 코드 중복 또는 코드 양의 증가로 이어짐.

```typescript
class Inventory {
  ledger = { total: 1200 };
}
class ItemsComponent {
  ledger: any;
  constructor(private inventory: Inventory) {
    this.ledger = inventory.ledger;
  }
  add(x) {
    this.ledger.total += x;
  }
}
class WidgetsComponent {
  ledger: any;
  constructor(private inventory: Inventory) {
    this.ledger = inventory.ledger;
  }
  add(x) {
    this.ledger.total += x;
  }
}
```

- `ItemsComponent`가 "절대로 `ledger`가 10을 넘지 않아야 한다"고 설정한 반면, `WidgetsComponent`는 "11로 설정하자"고 한다면 `ItemsComponent`가 고장날 수 있음.
- `WidgetsComponent`는 "11로 설정하지 말아야 한다"는 사실을 어떻게 알 수 있을까? 이제 `WidgetsComponent`는 `ItemsComponent`의 요구 사항에 대해 알아야만 함.
- 또한 공유된 상태가 있기 때문에, 상태를 공유하는 모든 구성 요소의 비즈니스 요구 사항과 로직이 서로 결합되어 있음.

# 목표

- 복잡성 (상태 관리), 제어 흐름, 코드 양을 관리하기
